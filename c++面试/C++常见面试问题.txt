在基类中定义了public虚函数，在派生类中将其重写，但是设置为private，为什么通过基类指针仍然可以发生动态绑定调用派生类中的private虚函数？
class Base
{
public:
    // public虚函数
    virtual void Disp() { cout << "base.\n"; }
};
class Derived : public Base
{
private:
    // 重写基类虚函数，但是放在private中
    virtual void Disp() { cout << "derived.\n"; }
};
void main()
{
    Derived Dobj;
    Base *pBase = &Dobj;
    pBase->Disp();    // 显示的结果是派生类的虚函数被调用！
}
虚函数是通过虚表来实现的。虚表可以理解为一个函数指针数组，编译器会根据函数名称和原型找到对应函数在虚表中的index. 派生类可能override了基类的实现，这样只是虚表中的函数指针变了，索引并没变。
又因为是通过基类的指针调用的，访问权限也是按照基类的。很简单的东西，要解释清楚却很费事 :)
可访问性是静态解析的，不是动态解析的。即是说，无论最终覆盖者的可访问性如何，可访问性均取决于函数调用后缀表达式的可访问性。



参考一下singleton设计模式。

如何让类只在堆或栈上创建；
答：只在堆上：编译器在为类对象分配栈空间时会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。
如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。
只在栈上：可以将operator new操作符重载并设置为私有访问即可。

多态中的虚函数表是在运行时创建的还是编译时创建的？
答：虚函数表在编译的时候就确定了，而类对象的虚函数指针vptr是在运行阶段确定的，这是实现多态的关键


构造函数可以为虚吗，析构函数为什么必须为虚
答：不可以，因为编译器创建对象，必须根据类类型来确定，并调用其构造函数。而虚函数是根据对象的类型去寻找虚函数表。
两者之间相互矛盾。
析构函数设为虚函数的原因是为了防止内存泄露。用基类delete时，如果析构函数没有声明为虚函数，只能析构基类对象，派生类对象将无法析构。


构造函数可以抛异常吗，析构函数可以抛异常吗
答：构造函数中抛出异常，会导致析构函数不能被调用，但对象本身已申请到的内存资源会被系统释放，可能会造成内存泄露或系统资源未被释放。
 不要在析构函数中抛出异常！虽然C++并不禁止析构函数抛出异常，但这样会导致程序过早结束或出现不明确的行为。
如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。
析构函数中异常非抛不可，那就用try catch来将异常吞下，

new 和 malloc 的区别， new 和new 【】 区别
答：1.是否调用构造函数/析构函数    2.是否需要指定内存大小   3.返回类型安全性
new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。
注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。

new与malloc是否可以相互调用
答：operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。

四种转换类型
答：static_cast： 1）完成基础数据类型，2）同一个继承体系中类型的转换 3）任意类型与空指针类型void*之间的转换。 编译时期的静态类型检测
dynamic_cast：使用多态的场景，增加了一层对真实调用对象类型的检查，向上转换成功，向下转换不安全，返回NULL。  运行时检测.
dynamic_cast是4个转换中唯一的RTTI操作符，提供运行时类型检查。
const_cast  去除const常量属性，使其可以修改 ，volatile属性的转换
reinterpret_cast 和C的强制转换没什么区别，重新定义内存。

向上转换和向下转换 
答：将派生类的引用或指针转换为基类的引用或指针被称为向上强制转换。（安全的，可传递的）
将基类的引用或指针转换为派生类的引用或指针被称为向下强制转换。（不安全的，可传递的）必须使用显式强制转换，可能带来不安全操作

左值 右值   ，左值引用，右值引用
答：在C++11中可以取地址的、有名字的就是左值。不能取地址的、没有名字的就是右值。右值又可以细分为纯右值、将亡值。
纯右值指的是临时变量和不跟对象关联的字面量值，将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用）。
将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。
在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。
常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。
右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，
移动语义解决了拷贝语文带来的拷贝开销，在拷贝内存较大时，性能犹为明显
移动构造函数的参数是 (T && b)，右值引用参数可以接收的值为非常量右值，其它值都不可以转化为右值引用参数，所以必须要用到std::move


如何在main函数之前执行函数/主函数之前还会执行什么
答：声明一个全局对象，在main之前调用构造函数

多态，虚函数相关集合。
多态性可以简单概括为“一个接口，多种行为”。不同的对象在调用函数时会产生不同的行为。
多态分为两种：
        （1）编译时多态：主要通过函数的重载和模板来实现。
        （2）运行时多态：主要通过虚函数来实现。
多态的几个相关概念：
（1）重载（overload）
   指同一个作用域出生多个函数名相同，但是形参类型不同，个数不同，顺序不同的函数。编译器在编译的时候，通过实参的个数和类型（const算，virtural不算），选择最终调用的函数。
（2）覆盖、重写（override）
   override指基类的某个成员函数为虚函数，派生类又定义一成员函数，除函数体的其余部分都与基类的成员函数相同。注意，如果只是函数名相同，形参或返回类型不同的话，就不能称为override，而是hide。
（3）隐藏（hide）
        分为两种：
            //1）局部变量或者函数隐藏了全局变量或者函数（对全局变量来说）
            2）派生类拥有和基类同名的成员函数或成员变量。（对类来说）

栈溢出有几种方式
局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。
递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。
指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。

内存泄漏有哪几种方式 
1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数
2.在释放对象数组时在delete中没有使用方括号
3.没有将基类的析构函数定义为虚函数
4.缺少拷贝构造函数，缺少重载赋值运算符。
5.申请内存后，没有在所有出口处都释放，比如抛出异常处。

野指针？
野指针：指向被释放的或者访问受限内存的指针。
造成野指针的原因：


1.指针变量没有被初始化（如果值不定，可以初始化为NULL）

2.指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL.

3.指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。（函数内部定义的指针，返回时已经被销毁）。

C++ 空类，默认产生哪些成员函数？
默认构造函数、默认拷贝构造函数、默认析构函数、默认赋值运算符、取址运算符、 取址运算符 const
这些函数，只有在没有时，才会默认生成。而如果提供了声明，即使没有实现，也不会生成默认的函数。

拷贝构造函数不能由成员函数模版生成。
原因很简单，成员函数模版并不改变语言的规则，而语言的规则说，如果程序需要一个拷贝构造函数而你没 
有声明它，那么编译器会为你自动生成一个。所以成员函数模版并不会阻止编译器生成拷贝构造函数， 赋值运算 
符重载也遵循同样的规则。

C++空类大小为何是1？
每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址．所以大小为１.

C++ 中const、 volatile、restrict
const 类型的对象在程序执行期间不能被修改改变。
修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。
restrict是一个限定符，主要用来修饰指针指向的内存不能被别的指针引用。

const在C语言和C++中的区别
C语言中const是定义了一个const变量，该变量只具备读的功能，不具备写的功能。
C++中const是定义了一个常量。
C语言中不能定义const函数，而C++中可以定义const函数

二叉排序树，AVL树，B树，B+树
2-3树的2节点包含一个元素和两个孩子，要么没有孩子，要么两个孩子。
3节点包含一大一小两个元素和三个孩子或没有孩子。
2-3树的插入分三种：
1.空树，插入2节点。
2.插入节点到一个2节点，将其升级为3节点。
3.插入节点到一个3节点，将该节点的两个元素和插入元素选一个，往上移动一层。（3种）
删除分三种：
1.删除元素位于是3节点的叶子节点上，将其变为2节点即可。
2删除元素节点位于2节点上。分四种
3.删除元素位于非叶子的分支节点。
2-3， 2-3-4树都是B树，结点最大孩子的数目叫做B树的阶。（M）
B树的性质：
1.如果根节点不是叶节点，那么至少有两颗子树。
2.非根节点都有K-1元素和K个孩子。  （M/2<=K<=M）
3.所有叶节点位于同一层次。
B+树与B树的区别：
1.有N棵子树的节点中包含有N个关键字。
2.所有的叶子节点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子节点本身依
关键字的大小自小而大顺序链接。
3.所有分支节点可以看成是索引，节点中仅含有其子树中的最大（最小）关键字。
B+树特别适合带有范围的查找。

哈希函数构造方法。
1.直接定址法。取关键字的某个线性函数值为散列地址。
2.数字分析法。
3.平方取中法。
4.折叠法。
5.除留余数法。
哈希冲突的解决方法：
1.开放定址法。冲突后寻找下一个空地址。（线性探测法）还有二次探测法。随机探测法。
2.再哈希。
3.链地址法。（用的最多）
4.公共溢出区。