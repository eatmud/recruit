C++的多态性用一句话概括就是：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数；
子类对象想调用父类的成员函数，需要显式声明，父类名：：成员函数名。

编译器在编译的时候，发现Father类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表(即 vtable)，该表是一个一维数组，在这个数组中存放每个虚函数的地址
编译器另外还为每个对象提供了一个虚表指针(即vptr)，这个指针指向了对象所属类的虚表，在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向了所属类的虚表，从而在调用虚函数的时候，能够找到正确的函数，

在虚表指针没有正确初始化之前，我们不能够去调用虚函数，那么虚表指针是在什么时候，或者什么地方初始化呢？
在构造函数中进行虚表的创建和虚表指针的初始化，在构造子类对象时，要先调用父类的构造函数，此时编译器只“看到了”父类，并不知道后面是否还有继承者，它初始化父类对象的虚表指针，该虚表指针指向父类的虚表，
当执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。

注意  重载，覆盖，隐藏的区别
重载的特征有：
1) 相同的范围（在同一个类中）；
2) 函数名字相同；
3) 参数不同；
4) virtual关键字可有可无。
覆盖的特征有：
1) 不同的范围（分别位于派生类与基类）；
2) 函数名字相同；
3) 参数相同；
4) 基类函数必须有virtual关键字。
隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
1) 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
2) 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

重载(overload)
在同个space域同名的.
参数必须不同,有无virtual无关.

覆盖(override)
同名字,同参数,有virtual

隐藏hide
1,同名同参无virtual
2,同名不同参不管有无virtual

stl容器中都是按值传递，用容器装自定义类型的时候，自定义类型的拷贝构造函数必须定义完整且没有错误，否则装进去也会出错，如果拷贝的东西涉及到指针，还必须考虑深拷贝和浅拷贝的问题；

empty直接检查标记节点，而size是通过求首尾迭代器的距离来获取元素个数的。
empty 对所有的标准容器都是常数时间操作，而对一些list 实现，size 耗费线性时间。

 1. 空的vector对象，size()和capacity()都为0
 2. 当空间大小不足时，新分配的空间大小为原空间大小的2倍。
 3. 使用reserve()预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率。
 4. 当reserve()分配的空间比原空间小时，是不会引起重新分配的。
 5. resize()函数只改变容器的元素数目，未改变容器大小。

C++ 中vector的clear()只是清空vector，并不会清空开的内存。用一种方法可以清空vector的内存。先定义一个空的vector x, 然后用需要清空的vector和x交换，因为x是局部变量，所以会被系统回收内存（注意 大括号一定不能去掉）。


c++迭代器失效
迭代器失效分三种情况考虑，也是分三种数据结构考虑，分别为数组型，链表型，树型数据结构。
数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);
链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).
树形数据结构： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。
注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*ite


1.1、栈区（stack）-由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
1.2、堆区（heap）-一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
1.3、全局区（静态区）（static）-全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
1.4、文字常量区-常量字符串就是放在这里的。程序结束后由系统释放。
1.5、程序代码区(该段代码详细讲述分配的堆栈，十分有用)



c++ 容器中为什么不能装对象的引用
在STL中，容器的元素要满足三个基本要求：可拷贝(copyable)、可赋值(assignable)、可析构(destroyable)。基本数据类型和自定义的类都满足这些条件，但是引用不满足，因为引用不能析构。



1). 一个参数既可以是const还可以是volatile吗？解释为什么。
    2). 一个指针可以是volatile 吗？解释为什么。
    3). 下面的函数有什么错误：
         int square(volatile int *ptr)
         {
              return *ptr * *ptr;
         }
    下面是答案：
    1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
    2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
    3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
    int square(volatile int *ptr)
    {
         int a,b;
         a = *ptr;
        b = *ptr;
         return a * b;
     }
    由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
     long square(volatile int *ptr)
     {
            int a;
            a = *ptr;
            return a * a;
     }

类的静态成员函数不与特定的对象关联，因此只能使用静态数据成员。且不能通过对象调用。


公有继承时,基类的private成员派生类也不可用,基类的public和protected成员在派生类中可直接使用.继承过来(变成派生类相应的public和protected成员)只有public成员在派生类外可以直接使用.

保护继承时,基类的private成员仍为有私有.基类的public和protected成员变成派生类的protected成员,这时在派生类外也不能直接使用原基类的public成员

私有继承时,基类的private成员仍为有私有.基类的public和protected成员将变成派生类的private成员.

public继承
派生类通过public继承，基类的各种权限不变 。
派生类的变量和函数成员，可以访问基类的public成员（类内，类外都可）、protected成员（类内可，类外不可），但是无法访问基类的private成员（类内，类外都不可）。
可以将public继承看成派生类将基类的public,protected成员囊括到派生类，但是不包括private成员。

protected继承
private成员是基类内部的隐私，除了友元，所有人员都不得窥探。派生类的友元，都不能访问

private继承
private成员是基类内部的隐私，除了友元，所有人员都不得窥探。派生类的友元，都不能访问


总结：继承修饰符，就像是一种筛子，将基类的成员筛到派生类。public、protected、private，就是筛子的眼。
通过public继承，所有基类成员（除了private），public、protected都到了派生类里面，public筛眼比较大，不会改变访问权限。
通过protected继承，所有基类成员（除了private），public、protected都到了派生类里面，protected筛眼大小适中，所有过来的成员都变成了protected。
通过private继承，所有基类成员（除了private），public、protected都到了派生类里面，private筛眼最小，所有过来的成员都变成了private。


typeid是一个C ++语言运算符，它在运行时返回类型标识信息。它基本上返回一个type_info与其他type_info对象相等的对象。
type_info对象唯一定义的属性是相等和不相等，即type_info描述不同类型的对象应比较不等于，而type_info描述相同类型的对象必须相等。
typeid是一个运行时结构，因此提供了有关该值的运行时类型的信息。
运行时获知变量类型名称，可以使用 typeid(变量).name()

typeid 是 C++ 的关键字之一，typeid操作符的返回结果是名为type_info的标准库类型的对象的引用（在头文件typeinfo中定义）。


如果表达式的类型是类类型且至少包含有一个虚函数，则typeid操作符返回表达式的动态类型，需要在运行时计算；否则，typeid操作符返回表达式的静态类型，在编译时就可以计算。

RTTI
我们先来了解一下RTTI（Run-Time Type Identification，运行时类型识别），它使程序能够获取由基指针或引用所指向的对象的实际派生类型，
即允许“用指向基类的指针或引用来操作对象”的程序能够获取到“这些指针或引用所指对象”的实际派生类型。


在C++中，为了支持RTTI提供了两个操作符：dynamic_cast和typeid

    dynamic_cast允许运行时刻进行类型转换，从而使程序能够在一个类层次结构中安全地转化类型


typeid是C++的关键字之一，等同于sizeof这类的操作符。typeid操作符的返回结果是名为type_info的标准库类型的对象的引用

如果表达式的类型是类类型且至少包含有一个虚函数，则typeid操作符返回表达式的动态类型，需要在运行时计算； 
否则，typeid操作符返回表达式的静态类型，在编译时就可以计算。

 没有虚函数与虚继承时，多重继承只是单纯的所有父类的大小和，内存有：N个祖父大小，N个父类新增大小。
只有虚函数，没有虚继承时，多重继承的内存有：N个祖父大小，N个父类新增大小，N个指向父类虚表的虚指针。
没有虚函数，只有虚继承时，多重继承的内存有：1个祖父大小，N个父类新增大小，N个指向父类虚表的虚指针。
既有虚函数，又有虚继承时，多重继承的内存有：1个祖父大小，N个父类新增大小，N个指向父类虚表的虚指针，一个自身用的虚指针。


C中malloc和free原理，为什么free释放不加大小
malloc()申请的空间实际我觉得就是分了两个不同性质的空间。一个就是用来记录管理信息的空间，另外一个就是可用空间了。而用来记录管理信息的实际上是一个结构体。
struct mem_control_block 
{
       int is_available;    //这是一个标记？
       int size;            //这是实际空间的大小
    };
https://blog.csdn.net/caogenwangbaoqiang/article/details/79834150