内联函数的作用？
内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。
需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终可执行程序的体积增加。 可以理解为以空间换时间的做法，提高效率，但是内联函数内不能用循环和过多判断等。inline只是给编译器建议，不一定采用。

C++ 不支持在函数外返回局部变量的地址（离开作用域变量销毁），可以返回局部指针，不过指针指向的东西被释放，具体内容不能保证，除非定义局部变量为 static 变量。

类的初始化列表语法：
1.只能用于构造函数。
2.数据成员被初始化的顺序，是按在类中声明的顺序，与初始化列表顺序无关。
3.非静态的 const成员和引用成员，必须通过初始化列表初始化。

定位new运算符，delete不能与定位new运算符配合使用，会导致运行时错误。
要为定位new分配的区域中，不同的内存单元，提供不能的位于缓冲区的位置。
要显式地使用定位new运算符创建的对象调用析构函数。

⒈为什么不能在类内初始化const？
关于这一点，网上最普遍的说法是：
const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类声明中初始化const数据成员，因为类的对象未被创建时，编译器不知道const 数据成员的值是什么。
但依本人愚见，更为主要的原因是：const数据成员是类内（in_class）成员（即类的不同对象中const数据成员的值可以不同）const int b;与int a;的不同仅在于，在一个对象中，a可以改b不可以改。无论对a还是b，初始化意味着为a和b分配内存，而我们知道，类是抽象的，并不占用内存，编译器编译时，根据类的数据成员计算出类的大小，但不进行内存分配操作（见注释②）。只有在实例化对象时，才为对象分配内存。如果初始化数据成员，一方面，初始化要分配内存，另一方面，声明类不分配内存，这显然是矛盾的。
另外，对多个对象而言，const是变量，如果在类内初始化const的话，那么由该类创建的多个对象中的const相同，这和我们的初衷是相违背的。
总之，在下个人认为，不能在类内初始化const与不能初始化int a的道理是一样的。

static 静态数据
①全局性：static（无论局部static还是全局static）分配在静态（或称全局）存储区, 在程序整个运行期间都不释放.
②初始化一次性： 无论是静态局部变量还是静态全局变量，都只初始化一次。
③记忆性：所谓”记忆性”是指在两次函数调用时, 在第二次调用进入时, 能保持第一次调用退出时的值，直至重新赋值。static具有全局唯一性的特点, 每次调用时, 都指向同一块内存。
④作用域限定性：函数或变量前加static。此时，函数的作用域仅局限于本文件。通常, 对于外部(全局)变量, 不论是否有static限制, 它的存储区域都是在静态存储区, 生存期都是全局的. static只是起作用域限制作用, 限定作用域在本模块(文件)内部.
对类的static数据成员，有：
1.静态数据成员只分配一次内存，供所有对象共用。 即静态数据成员独立于对象之外，放在一个单独的区域（静态数据区），为同一类的所以对象共享。
2.静态数据成员的值对每个对象都是一样的，但它的值可以改，一改全改
3.静态数据成员和普通数据成员一样遵从public, protected, private访问规则，private, protected的static成员虽然可以在类外初始化，但是不能在类外被访问。
4.static成员变量的初始化是在类外，因为static变量只是类的静态数据成员，类外声明时不能再带上static的关键字。
5.若不对静态数据成员初始化，系统自动将int型初始化为0。此时初始化语句还是要写，只不过不赋右值。
6.类的静态数据成员有两种访问形式：＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞
7.同全局变量相比，使用静态数据成员有两个优势：
静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；
可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

类中几种特殊的初始化：
1.static const和const static的初始化   同static初始化 一样
2.static的初始化		在类外初始化，不带static声明
3.非静态const初始化		类中构造函数初始化列表
4.static const int型 和static const char型数据成员可以在类内定义时初始化（C++ 11 之前）
5.从C++11允许对所有非静态成员变量（常量）在类内初始化
6.无论是static conat还是const static，初始化时const都不能省，static都不能加

为什么只有静态常量整型数据成员，才可以在类中初始化。
 这是因为，当时认为，类定义中的数据定义，是一种声明，不是数据定义。
 当用类定义对象（变量，常量）时候，才开始定义数据。


在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。
1.栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数、返回结果等。 相关代码执行时创建，执行结束时被自动释放。
由于栈是操作系统级提供的支持，有许多寄存器和相关指令，且只需要移动栈顶指针，因此栈的操作很快，效率很高，且自动释放内存。

2.自由存储区，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
是C++语言库的支持，底层的operate new（），调用了相关内存算法，寻找适当大小的内存，因此速度较栈要慢。

3.堆，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

4.全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。此时的内存在程序编译的时候已经分配好，并且在程序的整个运行期间都存在。全局变量，static变量等在此存储。

5.常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改

构造顺序：基类，类成员类，自身 ，析构顺序相反
创建派生类对象时，首先调用基类构造函数，再调用派生类构造函数。基类构造函数负责初始化继承的数据成员，派生类构造函数用于初始化新增的数据成员
派生类的构造函数总是调用一个基类构造函数，如果没有显示调用，就使用默认的。析构顺序与创建的顺序相反。

基类指针和基类引用 可以不进行显式转换的情况下指向派生类对象。如果没有声明为虚函数，那么通过基类指针引用调用的函数，是基类的函数方法。
不能将基类对象和地址赋给派生类的引用和指针。（即向下转换，类型不安全）
基类对象可以被初始化为派生类，也可以赋值。

调用方法时，如果不是虚函数，将根据指针或引用的类型选择方法，如果是虚函数，将根据指向对象的类型来选择方法。
在继承类中，想要调用基类的方法，可以用 基类名：：方法名的 方式，显式调用。

静态联编（早期），动态联编（晚期）。
静态联编效率更高，动态联编更灵活 。
虚函数的工作原理：
当类中有虚函数时，将为这种类生成一个虚函数表，表中存储了为类对象进行声明的虚函数的地址。生成对象时，将为对象添加一个隐藏的指针，指向
所对应的虚函数表，在表中查找对应的虚函数。

友元函数不能是虚函数。因为友元函数不是类成员，只有成员才能是虚函数。
友元函数在内中声明时要有friend关键字，在外面定义时不要有。
类的static成员变量和成员函数也是。



模版类在编译时是在使用的地方才实例化，但不同的.cpp文件是在link时才相互关联，因此编译main.cpp时只实例化了函数的声明，并且认为在某个地方已经实例化了函数的定义


返回类型协变
基类的虚函数返回类型是 基类的指针或引用，那么继承类的该函数返回值可以变为派生类的指针或引用
如果基类的虚函数被重载过，比如3种，在继承类中如果只重新定义了一个版本，那么另外两个版本将被隐藏。

c++允许纯虚函数有定义，但不能在类中定义
基类和派生类都采用动态内存分配时，派生类的析构函数，复制构造函数，赋值运算符根据派生类有无new决定是否可以使用默认的上述三个函数。
（P520）

静态成员函数没有 this 指针，即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。
静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。
静态成员函数和静态成员变量都可以通过   1.类名：：   2.对象名.    两种方式访问。

一个派生类继承了所有的基类方法，但下列情况除外：
基类的构造函数、析构函数和拷贝构造函数。
基类的重载运算符，取地址运算符，const取地址运算符。
基类的友元函数。

虚拟继承格式
class 类名: virtual 继承方式 父类名

静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定

虚函数可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。
纯虚函数可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。
编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论他们是private、protect或是public的，都会被统一的放置到虚函数表中。


  智能指针，头文件memory
基本语法，如 auto_ptr<string> ps(new string("aaa"));
主要是为动态分配的内存，经常忘记被释放。创建类的方式，让对象在过期时自动调用析构函数用delete来删除分配的内存。
不能用非堆内存的指针来初始化智能指针，不然对象过期的时候，delete用于非堆内存，这是错误的。

如果两个智能指针都指向同一块地址或对象，在删除时会对一个对象删除两次，为了避免出现这种情况。
1.为特定的对象建立所有权的概念，auto_ptr和unique_ptr都是，但后者更严格。
2.为特定的对象的智能指针数计数，赋值时+1，指针过期-1，当最后一个时才调用delete，   shared_ptr就是这种。

auto_ptr 可能出现的问题， auto_ptr指向一个对象，然后将指针赋给另一个指针，将交出所有权，指针地址将变为空指针。而shared_ptr采用计数，都可以访问
unique_ptr和auto_ptr 一样，但是auto_ptr可以编译，运行出错，unique_ptr编译就报错。

因此，unique_ptr 比 auto_ptr  更安全。unique_ptr 可以用于数组，即unique_ptr 有new【】和delete【】的变体。 unique_ptr <string【】> ps(new string("aaa"));
将一个unique_ptr  赋给另一个unique_ptr 时，允许右值传递，不允许左值。

基类中的public/protected/private成员，通过private继承，在子类中，都变成了private属性。
但是，对于子类，基类public成员,在派生类中变成了private,可以被派生类直接访问。
基类的protected成员，在派生类中变成了private,可以被派生类直接访问。
基类的private成员不能被派生类直接访问，只能调用基类的public和protect方法（虽然通过private继承全部在子类中变为了private）。

STL
vector支持随机访问，因此对迭代器重载了 begin()+2等操作。
类的特定算法比通用算法效率高。
STL常用的算法，for_each()，random_shuffle，sort（），


